"""Vulnerability detection using machine learning"""

import os
import json
import numpy as np
from typing import Dict, List, Set, Tuple, Optional, Any
from blackfyre.datatypes.contexts.binarycontext import BinaryContext
from blackfyre.ml.feature_extractor import FunctionFeatureExtractor
from blackfyre.ml.model import FunctionClassifier

class VulnerabilityDetector:
    """Detect potential vulnerabilities using machine learning"""
    
    def __init__(self, binary_context: BinaryContext, model_path: Optional[str] = None):
        """Initialize the vulnerability detector
        
        Args:
            binary_context: The BinaryContext to analyze
            model_path: Path to a pre-trained model (optional)
        """
        self.binary_context = binary_context
        self.classifier = None
        
        if model_path is not None and os.path.exists(model_path):
            self.classifier = FunctionClassifier.load_model(model_path)
            
        # Define vulnerability patterns to check
        self.patterns = self._get_vulnerability_patterns()
    
    def _get_vulnerability_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Get patterns for common vulnerabilities
        
        Returns:
            Dictionary of vulnerability patterns
        """
        return {
            "buffer_overflow": {
                "risk": "high",
                "description": "Potential buffer overflow vulnerability",
                "functions": ["strcpy", "strcat", "sprintf", "gets", "scanf"],
                "conditions": {
                    "string_ref_count": 1,
                    "has_loop": True
                }
            },
            "format_string": {
                "risk": "high",
                "description": "Potential format string vulnerability",
                "functions": ["printf", "fprintf", "sprintf", "snprintf"],
                "keywords": ["format", "%s", "%d", "%x"]
            },
            "command_injection": {
                "risk": "high",
                "description": "Potential command injection vulnerability",
                "functions": ["system", "popen", "exec", "execl", "execlp", "execle", "execv", "execvp", "execvpe"],
                "keywords": ["cmd", "command", "shell"]
            },
            "info_leak": {
                "risk": "medium",
                "description": "Potential information leak",
                "functions": ["memcpy", "read", "fread"],
                "keywords": ["password", "secret", "key", "token", "credential"]
            }
        }
    
    def _check_function_calls_vulnerability(self, function_addr: int, pattern: Dict[str, Any]) -> bool:
        """Check if a function calls potentially vulnerable functions
        
        Args:
            function_addr: Address of the function to check
            pattern: Vulnerability pattern to check against
            
        Returns:
            True if potential vulnerability is detected
        """
        function = self.binary_context.function_context_dict[function_addr]
        
        # Check if the function calls any of the vulnerable functions
        if not hasattr(function, 'callees'):
            return False
            
        for callee_addr in function.callees:
            if callee_addr not in self.binary_context.function_context_dict:
                continue
                
            callee = self.binary_context.function_context_dict[callee_addr]
            if any(vuln_func.lower() in callee.name.lower() for vuln_func in pattern["functions"]):
                return True
                
        return False
    
    def _check_function_strings(self, function_addr: int, pattern: Dict[str, Any]) -> bool:
        """Check if a function uses strings related to vulnerabilities
        
        Args:
            function_addr: Address of the function to check
            pattern: Vulnerability pattern to check against
            
        Returns:
            True if suspicious strings are detected
        """
        function = self.binary_context.function_context_dict[function_addr]
        
        # Check for suspicious strings
        if not hasattr(function, 'string_refs'):
            return False
            
        for string_val in function.string_refs.values():
            if any(keyword.lower() in string_val.lower() for keyword in pattern.get("keywords", [])):
                return True
                
        return False
    
    def detect_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Detect potential vulnerabilities in the binary
        
        Returns:
            List of potential vulnerability findings
        """
        findings = []
        
        # Check each function against vulnerability patterns
        for addr, function in self.binary_context.function_context_dict.items():
            for pattern_name, pattern in self.patterns.items():
                # Check for calls to vulnerable functions
                calls_vulnerable = self._check_function_calls_vulnerability(addr, pattern)
                
                # Check for suspicious strings
                has_suspicious_strings = self._check_function_strings(addr, pattern)
                
                if calls_vulnerable or has_suspicious_strings:
                    findings.append({
                        "type": pattern_name,
                        "risk": pattern["risk"],
                        "description": pattern["description"],
                        "function": {
                            "address": addr,
                            "name": function.name,
                            "size": function.end_address - function.start_address
                        },
                        "evidence": {
                            "calls_vulnerable_function": calls_vulnerable,
                            "has_suspicious_strings": has_suspicious_strings
                        }
                    })
        
        # If we have a classifier, use it to classify potentially vulnerable functions
        if self.classifier is not None:
            feature_extractor = FunctionFeatureExtractor(self.binary_context)
            
            for finding in findings:
                addr = finding["function"]["address"]
                try:
                    # Extract features and classify function
                    features = feature_extractor.extract_all_features(addr)
                    prediction = self.classifier.predict_function(features)
                    
                    # Add classification information to the finding
                    finding["ml_analysis"] = {
                        "predicted_class": prediction["predicted_class"],
                        "confidence": prediction["confidence"]
                    }
                except Exception as e:
                    print(f"Error classifying function at {hex(addr)}: {e}")
        
        # Sort findings by risk level
        risk_levels = {"high": 3, "medium": 2, "low": 1}
        findings.sort(key=lambda x: risk_levels.get(x["risk"], 0), reverse=True)
        
        return findings
    
    def generate_report(self, findings: Optional[List[Dict]] = None, output_file: Optional[str] = None) -> str:
        """Generate a vulnerability report
        
        Args:
            findings: Vulnerability findings (if None, will detect them)
            output_file: Optional path to write the report to
            
        Returns:
            Report as a string (markdown format)
        """
        if findings is None:
            findings = self.detect_vulnerabilities()
        
        # Count findings by risk level
        risk_counts = {"high": 0, "medium": 0, "low": 0}
        for finding in findings:
            risk = finding.get("risk", "low")
            risk_counts[risk] = risk_counts.get(risk, 0) + 1
        
        # Generate markdown report
        report = f"""# Vulnerability Analysis Report

## Binary Information
- **Name:** {self.binary_context.name}
- **SHA-256:** {self.binary_context.sha256_hash}

## Summary
- **Total Potential Vulnerabilities:** {len(findings)}
- **High Risk:** {risk_counts.get("high", 0)}
- **Medium Risk:** {risk_counts.get("medium", 0)}
- **Low Risk:** {risk_counts.get("low", 0)}

## Detailed Findings
"""
        
        # Add details for each finding
        for i, finding in enumerate(findings, 1):
            func = finding["function"]
            
            report += f"### {i}. {finding['description']} in {func['name']} (0x{func['address']:x})\n"
            report += f"- **Risk Level:** {finding['risk'].upper()}\n"
            report += f"- **Vulnerability Type:** {finding['type']}\n"
            report += f"- **Function Size:** {func['size']} bytes\n"
            
            # Add evidence details
            evidence = finding.get("evidence", {})
            if evidence:
                report += "- **Evidence:**\n"
                for key, value in evidence.items():
                    if value:
                        report += f"  - {key}: Yes\n"
            
            # Add ML analysis if available
            if "ml_analysis" in finding:
                ml = finding["ml_analysis"]
                report += f"- **ML Classification:** {ml['predicted_class']} (confidence: {ml['confidence']:.2f})\n"
                
            report += "\n"
        
        # Write to file if requested
        if output_file:
            with open(output_file, 'w') as f:
                f.write(report)
            print(f"Vulnerability report written to {output_file}")
        
        return report
